"""
Crew API endpoints for managing CrewAI crews.

This module provides endpoints for running, pausing, and resuming CrewAI crews,
as well as retrieving crew results and status.
"""

import logging
from typing import Dict, List, Optional, Any, Union
from fastapi import APIRouter, HTTPException, Depends, Request, status
from pydantic import BaseModel, Field
from datetime import datetime, timedelta

from backend.agents.factory import CrewFactory, RUNNING_CREWS
from backend.auth.rbac import require_roles, Roles, RoleSets


# Configure logging
logger = logging.getLogger(__name__)
router = APIRouter()


# Request/Response Models
class CrewRunRequest(BaseModel):
    """Request model for running a crew."""
    crew_name: str = Field(..., description="Name of the crew to run")
    inputs: Optional[Dict[str, Any]] = Field(None, description="Inputs for the crew")


class CrewPauseRequest(BaseModel):
    """Request model for pausing a crew."""
    task_id: str = Field(..., description="ID of the task to pause")
    reason: Optional[str] = Field(None, description="Reason for pausing")
    review_id: Optional[str] = Field(None, description="ID of the associated review")


class CrewResumeRequest(BaseModel):
    """Request model for resuming a crew."""
    task_id: str = Field(..., description="ID of the task to resume")
    review_result: Optional[Dict[str, Any]] = Field(None, description="Result of the review")


class CrewResponse(BaseModel):
    """Response model for crew operations."""
    success: bool = Field(..., description="Whether the operation was successful")
    task_id: Optional[str] = Field(None, description="ID of the task")
    result: Optional[str] = Field(None, description="Result of the crew execution")
    error: Optional[str] = Field(None, description="Error message if any")


class TaskListItem(BaseModel):
    """Model for a task in the task list."""
    task_id: str = Field(..., description="Task ID")
    crew_name: str = Field(..., description="Name of the crew")
    state: str = Field(..., description="Current state of the task")
    start_time: str = Field(..., description="Time when the task started")
    last_updated: str = Field(..., description="Time when the task was last updated")
    current_agent: Optional[str] = Field(None, description="Current agent processing the task")
    error: Optional[str] = Field(None, description="Error message if any")
    review_id: Optional[str] = Field(None, description="ID of associated review if paused for HITL")


class TaskListResponse(BaseModel):
    """Response model for listing tasks."""
    tasks: List[TaskListItem] = Field(..., description="List of tasks")
    total: int = Field(..., description="Total number of tasks")


class TaskResultResponse(BaseModel):
    """Response model for task results."""
    task_id: str = Field(..., description="Task ID")
    crew_name: str = Field(..., description="Name of the crew")
    state: str = Field(..., description="Current state of the task")
    start_time: str = Field(..., description="Time when the task started")
    completion_time: Optional[str] = Field(None, description="Time when the task completed")
    result: Optional[str] = Field(None, description="Raw result of the crew execution")
    report: Optional[str] = Field(None, description="Formatted report from the crew")
    visualizations: Optional[List[Dict[str, Any]]] = Field(None, description="Visualizations generated by the crew")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata about the task")


# Endpoints
@router.post(
    "/run",
    response_model=CrewResponse,
    summary="Run a crew",
    description="Run a CrewAI crew with the specified inputs."
)
async def run_crew(
    request: CrewRunRequest,
    roles: RoleSets = Depends(require_roles([Roles.ANALYST, Roles.ADMIN]))
):
    """
    Run a CrewAI crew.
    
    Args:
        request (CrewRunRequest): Request model with crew name and inputs.
        
    Returns:
        CrewResponse: Response with task ID and result.
    """
    # Create factory
    factory = CrewFactory()
    
    # Run crew
    result = await factory.run_crew(request.crew_name, request.inputs)
    
    # Create response
    response = CrewResponse(
        success=result["success"],
        task_id=result.get("task_id"),
        result=result.get("result"),
        error=result.get("error")
    )
    
    return response


@router.post(
    "/pause",
    response_model=CrewResponse,
    summary="Pause a crew",
    description="Pause a running CrewAI crew."
)
async def pause_crew(
    request: CrewPauseRequest,
    roles: RoleSets = Depends(require_roles([Roles.ANALYST, Roles.ADMIN]))
):
    """
    Pause a running CrewAI crew.
    
    Args:
        request (CrewPauseRequest): Request model with task ID and reason.
        
    Returns:
        CrewResponse: Response indicating success or failure.
    """
    # Pause crew
    success = CrewFactory.pause_crew(request.task_id, request.reason, request.review_id)
    
    # Create response
    response = CrewResponse(
        success=success,
        task_id=request.task_id,
        error=None if success else "Failed to pause crew"
    )
    
    return response


@router.post(
    "/resume",
    response_model=CrewResponse,
    summary="Resume a crew",
    description="Resume a paused CrewAI crew."
)
async def resume_crew(
    request: CrewResumeRequest,
    roles: RoleSets = Depends(require_roles([Roles.ANALYST, Roles.ADMIN]))
):
    """
    Resume a paused CrewAI crew.
    
    Args:
        request (CrewResumeRequest): Request model with task ID and review result.
        
    Returns:
        CrewResponse: Response indicating success or failure.
    """
    # Resume crew
    success = CrewFactory.resume_crew(request.task_id, request.review_result)
    
    # Create response
    response = CrewResponse(
        success=success,
        task_id=request.task_id,
        error=None if success else "Failed to resume crew"
    )
    
    return response


@router.get(
    "/tasks",
    response_model=TaskListResponse,
    summary="List tasks",
    description="List all crew tasks with their current status."
)
async def list_tasks(
    state: Optional[str] = None,
    crew_name: Optional[str] = None,
    roles: RoleSets = Depends(require_roles([Roles.ANALYST, Roles.ADMIN]))
):
    """
    List all crew tasks with their current status.
    
    Args:
        state (str, optional): Filter by task state. Defaults to None.
        crew_name (str, optional): Filter by crew name. Defaults to None.
        
    Returns:
        TaskListResponse: List of tasks.
    """
    try:
        # Filter tasks
        filtered_tasks = []
        for task_id, task_data in RUNNING_CREWS.items():
            # Apply filters
            if state and task_data.get("state") != state:
                continue
            if crew_name and task_data.get("crew_name") != crew_name:
                continue
            
            # Add to list
            filtered_tasks.append(TaskListItem(
                task_id=task_id,
                crew_name=task_data.get("crew_name", "unknown"),
                state=task_data.get("state", "UNKNOWN"),
                start_time=task_data.get("start_time", datetime.now().isoformat()),
                last_updated=task_data.get("last_updated", datetime.now().isoformat()),
                current_agent=task_data.get("current_agent"),
                error=task_data.get("error"),
                review_id=task_data.get("review_id")
            ))
        
        # Sort by start_time (newest first)
        filtered_tasks.sort(key=lambda x: x.start_time, reverse=True)
        
        return TaskListResponse(
            tasks=filtered_tasks,
            total=len(filtered_tasks)
        )
    except Exception as e:
        logger.error(f"Failed to list tasks: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list tasks: {str(e)}"
        )


@router.get(
    "/{task_id}/result",
    response_model=TaskResultResponse,
    summary="Get task result",
    description="Get the result of a crew task."
)
async def get_task_result(
    task_id: str,
    roles: RoleSets = Depends(require_roles([Roles.ANALYST, Roles.ADMIN]))
):
    """
    Get the result of a crew task.
    
    Args:
        task_id (str): ID of the task.
        
    Returns:
        TaskResultResponse: Task result.
    """
    try:
        # Check if task exists
        if task_id not in RUNNING_CREWS:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Task '{task_id}' not found"
            )
        
        # Get task data
        task_data = RUNNING_CREWS[task_id]
        
        # Extract result
        result = task_data.get("result", "")
        
        # Extract report (from context if available)
        report = ""
        if "_context" in task_data.get("context", {}) and "report" in task_data["context"]["_context"]:
            report = task_data["context"]["_context"]["report"]
        
        # Extract visualizations (from context if available)
        visualizations = []
        if "_context" in task_data.get("context", {}) and "visualizations" in task_data["context"]["_context"]:
            visualizations = task_data["context"]["_context"]["visualizations"]
        
        # Build metadata
        metadata = {}
        if "inputs" in task_data:
            metadata["inputs"] = task_data["inputs"]
        
        # Add pause duration if applicable
        if task_data.get("paused_at") and task_data.get("resumed_at"):
            try:
                paused_at = datetime.fromisoformat(task_data["paused_at"])
                resumed_at = datetime.fromisoformat(task_data["resumed_at"])
                metadata["paused_duration"] = (resumed_at - paused_at).total_seconds()
            except Exception:
                pass
        
        # Create response
        response = TaskResultResponse(
            task_id=task_id,
            crew_name=task_data.get("crew_name", "unknown"),
            state=task_data.get("state", "UNKNOWN"),
            start_time=task_data.get("start_time", datetime.now().isoformat()),
            completion_time=task_data.get("completion_time"),
            result=result,
            report=report,
            visualizations=visualizations if visualizations else None,
            metadata=metadata
        )
        
        return response
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get task result: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get task result: {str(e)}"
        )
