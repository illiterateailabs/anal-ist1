"""
Covalent Balances Tool

This module provides a tool for interacting with the Covalent unified API for multi-chain blockchain data API.

Generated by new_provider_scaffold.py on 2025-06-28
"""

import logging
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Field, validator

from backend.agents.tools.base_tool import AbstractApiTool
from backend.integrations.covalent_client import CovalentClient

# Configure module logger
logger = logging.getLogger(__name__)


class CovalentBalancesToolRequest(BaseModel):
    """Request model for CovalentBalancesTool."""
    # Common parameters
    method: Optional[str] = Field(
        None,
        description="Method to call (e.g., get_token_balances)",
    )

    # Covalent-specific parameters
    chain_id: str = Field(description="Blockchain chain ID (e.g., '1' for Ethereum)")
    address: str = Field(description="Wallet address to get balances for")
    quote_currency: Optional[str] = Field("USD", description="Quote currency for pricing")
    no_nft_fetch: Optional[bool] = Field(True, description="Skip NFT fetching for faster response")

    @validator("method")
    def validate_method(cls, v):
        """Validate method parameter."""
        if v is not None and v not in ['get_token_balances']:
            raise ValueError(f"Invalid method: {v}. Must be one of: get_token_balances")
        return v

    @validator("chain_id")
    def validate_chain_id(cls, v):
        """Validate chain_id parameter."""
        supported_chains = ["1", "137", "8453", "10", "42161", "43114"]
        if v not in supported_chains:
            raise ValueError(f"Unsupported chain_id: {v}. Must be one of: {', '.join(supported_chains)}")
        return v


class CovalentBalancesTool(AbstractApiTool):
    """Tool for interacting with Covalent unified API for multi-chain blockchain data API."""

    name = "covalent_balances_tool"
    description = "Tool for retrieving token balances from Covalent API"
    provider_id = "covalent"
    data_types = ['wallet_balances', 'token_transfers']
    request_model = CovalentBalancesToolRequest

    def __init__(self):
        """Initialize the tool."""
        super().__init__()
        self.client = CovalentClient()

    async def _execute(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the tool with the given parameters."""
        # Validate parameters
        self._validate_parameters(params)

        # Determine which endpoint to call based on parameters
        if "method" in params and params["method"] is not None:
            method = params.pop("method")

            # Call the appropriate method
            if hasattr(self, method) and callable(getattr(self, method)):
                return await getattr(self, method)(params)
            else:
                raise ValueError(f"Unknown method: {method}")

        # Default to get_token_balances if no method specified
        return await self.get_token_balances(params)

    async def get_token_balances(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Call get_token_balances endpoint.

        Args:
            params: Request parameters

        Returns:
            Response data
        """
        chain_id = params.get("chain_id")
        address = params.get("address")

        # Build query parameters
        query_params = {}
        if "quote_currency" in params and params["quote_currency"] is not None:
            query_params["quote-currency"] = params["quote_currency"]
        if "no_nft_fetch" in params and params["no_nft_fetch"] is not None:
            query_params["no-nft-fetch"] = str(params["no_nft_fetch"]).lower()

        return await self.client.get_token_balances(chain_id, address, query_params)
