"""
Moralis Web3 API Client

This module provides a client for interacting with the Moralis Web3 API for NFT metadata and multi-chain data API.
It handles authentication, rate limiting, and request retries.

Generated by new_provider_scaffold.py on 2025-06-28
"""

import asyncio
import logging
import os
import time
from typing import Any, Dict, List, Optional, Union

import httpx

from backend.core.metrics import ApiMetrics
from backend.providers import get_provider

# Configure module logger
logger = logging.getLogger(__name__)


class MoralisClient:
    """Client for Moralis Web3 API for NFT metadata and multi-chain data API."""

    def __init__(
        self,
        api_key: Optional[str] = None,
        base_url: Optional[str] = None,
        timeout: float = 30.0,
    ):
        """
        Initialize the moralis client.

        Args:
            api_key: API key for authentication (defaults to environment variable)
            base_url: Base URL for API (defaults to provider registry)
            timeout: Request timeout in seconds
        """
        # Get provider configuration
        provider_config = get_provider("moralis")
        if not provider_config:
            raise ValueError(f"Provider 'moralis' not found in registry")

        # Set base URL
        self.base_url = base_url or provider_config.get("base_url", "https://deep-index.moralis.io/api/v2.2")

        # Set API key
        self.api_key = api_key or os.environ.get(
            "MORALIS_API_KEY",
            provider_config.get("auth", {}).get("key", "")
        )

        if not self.api_key and "api_key" != "none":
            logger.warning(f"No API key provided for moralis")

        # Set timeout
        self.timeout = timeout

        # Set up headers
        self.headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
        }

        # Add authentication header if needed
        if self.api_key:
            # Moralis uses X-API-Key header
            self.headers["X-API-Key"] = self.api_key

        # Add additional headers from provider config
        provider_headers = provider_config.get("headers", {})
        self.headers.update(provider_headers)

        # Get rate limit configuration
        self.rate_limit = provider_config.get("rate_limit", {
            "requests_per_minute": 120,
            "requests_per_day": 25000,
        })

        # Get retry configuration
        self.retry_config = provider_config.get("retry", {
            "max_retries": 3,
            "backoff_factor": 1.0,
            "retry_status_codes": [429, 500, 502, 503, 504],
        })

        logger.info(f"Initialized moralis client with base URL: {self.base_url}")

    async def _make_request(
        self,
        method: str,
        url: str,
        params: Optional[Dict[str, Any]] = None,
        data: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        Make an HTTP request to the API.

        Args:
            method: HTTP method (GET, POST, etc.)
            url: Request URL
            params: Query parameters
            data: Request body data
            headers: Additional headers

        Returns:
            Response data

        Raises:
            httpx.HTTPError: If the request fails
        """
        start_time = time.time()
        request_headers = {**self.headers}
        if headers:
            request_headers.update(headers)

        # Track API call
        endpoint = url.replace(self.base_url, "")
        api_metrics = ApiMetrics.track_call(
            provider="moralis",
            endpoint=endpoint,
            func=lambda: None,
            environment="development",
            version="1.9.0-beta",
        )

        # Make request with retries
        retries = 0
        max_retries = self.retry_config.get("max_retries", 3)
        backoff_factor = self.retry_config.get("backoff_factor", 1.0)
        retry_status_codes = self.retry_config.get("retry_status_codes", [429, 500, 502, 503, 504])

        while True:
            try:
                async with httpx.AsyncClient(timeout=self.timeout) as client:
                    response = await client.request(
                        method=method,
                        url=url,
                        params=params,
                        json=data,
                        headers=request_headers,
                    )

                    # Check for rate limiting
                    if response.status_code == 429:
                        retry_after = int(response.headers.get("Retry-After", 1))
                        logger.warning(f"Rate limited by moralis API. Retrying after {retry_after} seconds")
                        await asyncio.sleep(retry_after)
                        continue

                    # Check for successful response
                    response.raise_for_status()

                    # Parse response
                    response_data = response.json()

                    # Track successful call
                    api_metrics()

                    # Track duration
                    duration_ms = (time.time() - start_time) * 1000
                    from backend.core.metrics import external_api_duration_seconds
                    external_api_duration_seconds.labels(
                        provider="moralis",
                        endpoint=endpoint,
                        status="success",
                        environment="development",
                        version="1.9.0-beta",
                    ).observe(duration_ms / 1000)  # Convert to seconds

                    return response_data

            except httpx.HTTPStatusError as e:
                # Check if we should retry
                if e.response.status_code in retry_status_codes and retries < max_retries:
                    retries += 1
                    sleep_time = backoff_factor * (2 ** retries)
                    logger.warning(f"Request failed with status {e.response.status_code}. Retrying in {sleep_time} seconds...")
                    await asyncio.sleep(sleep_time)
                    continue

                # Track failed call
                duration_ms = (time.time() - start_time) * 1000
                from backend.core.metrics import external_api_duration_seconds
                external_api_duration_seconds.labels(
                    provider="moralis",
                    endpoint=endpoint,
                    status="error",
                    environment="development",
                    version="1.9.0-beta",
                ).observe(duration_ms / 1000)  # Convert to seconds

                logger.error(f"Request to moralis API failed: {e}")
                raise

            except Exception as e:
                # Track failed call
                duration_ms = (time.time() - start_time) * 1000
                from backend.core.metrics import external_api_duration_seconds
                external_api_duration_seconds.labels(
                    provider="moralis",
                    endpoint=endpoint,
                    status="error",
                    environment="development",
                    version="1.9.0-beta",
                ).observe(duration_ms / 1000)  # Convert to seconds

                logger.error(f"Request to moralis API failed: {e}")
                raise

    async def get_wallet_nfts(self, address: str, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Retrieve wallet NFTs from /{address}/nft endpoint."""
        url = f"{self.base_url}/{address}/nft"
        return await self._make_request("GET", url, params=params)

    async def get_nft_metadata(self, address: str, token_id: str, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Retrieve NFT metadata from /nft/{address}/{token_id} endpoint."""
        url = f"{self.base_url}/nft/{address}/{token_id}"
        return await self._make_request("GET", url, params=params)

    async def get_wallet_tokens(self, address: str, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Retrieve wallet ERC20 tokens from /{address}/erc20 endpoint."""
        url = f"{self.base_url}/{address}/erc20"
        return await self._make_request("GET", url, params=params)

    async def get_token_metadata(self, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Retrieve token metadata from /erc20/metadata endpoint."""
        url = f"{self.base_url}/erc20/metadata"
        return await self._make_request("GET", url, params=params)

    async def get_wallet_transactions(self, address: str, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Retrieve wallet transactions from /{address} endpoint."""
        url = f"{self.base_url}/{address}"
        return await self._make_request("GET", url, params=params)
