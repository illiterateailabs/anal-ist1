"""
Covalent Unified API Client

This module provides a client for interacting with the Covalent unified API for multi-chain blockchain data API.
It handles authentication, rate limiting, and request retries.

Generated by new_provider_scaffold.py on 2025-06-28
"""

import asyncio
import logging
import os
import time
from typing import Any, Dict, List, Optional, Union

import httpx

from backend.core.metrics import ApiMetrics
from backend.providers import get_provider

# Configure module logger
logger = logging.getLogger(__name__)


class CovalentClient:
    """Client for Covalent unified API for multi-chain blockchain data API."""

    def __init__(
        self,
        api_key: Optional[str] = None,
        base_url: Optional[str] = None,
        timeout: float = 30.0,
    ):
        """
        Initialize the covalent client.

        Args:
            api_key: API key for authentication (defaults to environment variable)
            base_url: Base URL for API (defaults to provider registry)
            timeout: Request timeout in seconds
        """
        # Get provider configuration
        provider_config = get_provider("covalent")
        if not provider_config:
            raise ValueError(f"Provider 'covalent' not found in registry")

        # Set base URL
        self.base_url = base_url or provider_config.get("base_url", "https://api.covalenthq.com/v1")

        # Set API key
        self.api_key = api_key or os.environ.get(
            "COVALENT_API_KEY",
            provider_config.get("auth", {}).get("key", "")
        )

        if not self.api_key and "api_key" != "none":
            logger.warning(f"No API key provided for covalent")

        # Set timeout
        self.timeout = timeout

        # Set up headers
        self.headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
        }

        # Add authentication header if needed
        if self.api_key:
            # Covalent uses the API key as a bearer token for Basic auth
            # The user just needs to provide the key, not the full "user:pass" string
            self.auth = (self.api_key, "")

        # Add additional headers from provider config
        provider_headers = provider_config.get("headers", {})
        self.headers.update(provider_headers)

        # Get rate limit configuration
        self.rate_limit = provider_config.get("rate_limit", {
            "requests_per_minute": 100,
            "requests_per_day": 10000,
        })

        # Get retry configuration
        self.retry_config = provider_config.get("retry", {
            "max_retries": 3,
            "backoff_factor": 1.0,
            "retry_status_codes": [429, 500, 502, 503, 504],
        })

        logger.info(f"Initialized covalent client with base URL: {self.base_url}")

    async def _make_request(
        self,
        method: str,
        url: str,
        params: Optional[Dict[str, Any]] = None,
        data: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        Make an HTTP request to the API.

        Args:
            method: HTTP method (GET, POST, etc.)
            url: Request URL
            params: Query parameters
            data: Request body data
            headers: Additional headers

        Returns:
            Response data

        Raises:
            httpx.HTTPError: If the request fails
        """
        start_time = time.time()
        request_headers = {**self.headers}
        if headers:
            request_headers.update(headers)

        # Track API call
        endpoint = url.replace(self.base_url, "")
        api_metrics = ApiMetrics.track_call(
            provider="covalent",
            endpoint=endpoint,
            func=lambda: None,
            environment="development",
            version="1.8.0-beta",
        )

        # Make request with retries
        retries = 0
        max_retries = self.retry_config.get("max_retries", 3)
        backoff_factor = self.retry_config.get("backoff_factor", 1.0)
        retry_status_codes = self.retry_config.get("retry_status_codes", [429, 500, 502, 503, 504])

        while True:
            try:
                async with httpx.AsyncClient(timeout=self.timeout, auth=self.auth) as client:
                    response = await client.request(
                        method=method,
                        url=url,
                        params=params,
                        json=data,
                        headers=request_headers,
                    )

                    # Check for rate limiting
                    if response.status_code == 429:
                        retry_after = int(response.headers.get("Retry-After", 1))
                        logger.warning(f"Rate limited by covalent API. Retrying after {retry_after} seconds")
                        await asyncio.sleep(retry_after)
                        continue

                    # Check for successful response
                    response.raise_for_status()

                    # Parse response
                    response_data = response.json()

                    # Track successful call
                    api_metrics()

                    # Track duration
                    duration_ms = (time.time() - start_time) * 1000
                    from backend.core.metrics import external_api_duration_seconds
                    external_api_duration_seconds.labels(
                        provider="covalent",
                        endpoint=endpoint,
                        status="success",
                        environment="development",
                        version="1.8.0-beta",
                    ).observe(duration_ms / 1000)  # Convert to seconds

                    return response_data

            except httpx.HTTPStatusError as e:
                # Check if we should retry
                if e.response.status_code in retry_status_codes and retries < max_retries:
                    retries += 1
                    sleep_time = backoff_factor * (2 ** retries)
                    logger.warning(f"Request failed with status {e.response.status_code}. Retrying in {sleep_time} seconds...")
                    await asyncio.sleep(sleep_time)
                    continue

                # Track failed call
                duration_ms = (time.time() - start_time) * 1000
                from backend.core.metrics import external_api_duration_seconds
                external_api_duration_seconds.labels(
                    provider="covalent",
                    endpoint=endpoint,
                    status="error",
                    environment="development",
                    version="1.8.0-beta",
                ).observe(duration_ms / 1000)  # Convert to seconds

                logger.error(f"Request to covalent API failed: {e}")
                raise

            except Exception as e:
                # Track failed call
                duration_ms = (time.time() - start_time) * 1000
                from backend.core.metrics import external_api_duration_seconds
                external_api_duration_seconds.labels(
                    provider="covalent",
                    endpoint=endpoint,
                    status="error",
                    environment="development",
                    version="1.8.0-beta",
                ).observe(duration_ms / 1000)  # Convert to seconds

                logger.error(f"Request to covalent API failed: {e}")
                raise

    async def get_token_balances(self, chain_id: str, address: str, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Retrieve token balances from /{chain_id}/address/{address}/balances_v2/ endpoint."""
        url = f"{self.base_url}/{chain_id}/address/{address}/balances_v2/"
        return await self._make_request("GET", url, params=params)

    async def get_transactions(self, chain_id: str, address: str, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Retrieve transaction history from /{chain_id}/address/{address}/transactions_v3/ endpoint."""
        url = f"{self.base_url}/{chain_id}/address/{address}/transactions_v3/"
        return await self._make_request("GET", url, params=params)

    async def get_nft_balances(self, chain_id: str, address: str, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Retrieve NFT balances from /{chain_id}/address/{address}/balances_nft/ endpoint."""
        url = f"{self.base_url}/{chain_id}/address/{address}/balances_nft/"
        return await self._make_request("GET", url, params=params)

    async def get_token_metadata(self, chain_id: str, token_address: str, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Retrieve token metadata from /{chain_id}/tokens/{token_address}/ endpoint."""
        url = f"{self.base_url}/{chain_id}/tokens/{token_address}/"
        return await self._make_request("GET", url, params=params)
